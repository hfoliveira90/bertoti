We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. 
On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. 
In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce 
as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions 
with higher-stakes outcomes, often based on imprecise estimates of time and growth.


Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant 
part of software engineering: after all, programming is how you generate new software in the first place. If you accept this 
distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering 
tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t 
squares, distance isn’t velocity. Software engineering isn’t programming.

----------------------------------------------------------------------------------------------------------------------------------

Vemos três diferenças críticas entre programação e engenharia de software: tempo, escala e as compensações em jogo. Em um projeto de engenharia de software, os engenheiros precisam estar mais preocupados com a passagem do tempo e com a eventual necessidade de mudanças. Numa organização de engenharia de software, precisamos de estar mais preocupados com a escala e a eficiência, tanto para o software que produzimos como para a organização que o produz. Finalmente, como engenheiros de software, somos solicitados a tomar decisões mais complexas com resultados de maior risco, muitas vezes baseados em estimativas imprecisas de tempo e crescimento.

No Google, às vezes dizemos: “Engenharia de software é programação integrada ao longo do tempo”. A programação é certamente uma parte significativa da engenharia de software: afinal, a programação é como você gera um novo software. Se você aceitar essa distinção, também ficará claro que talvez seja necessário delinear entre tarefas de programação (desenvolvimento) e tarefas de engenharia de software (desenvolvimento, modificação, manutenção). A adição de tempo acrescenta uma nova dimensão importante à programação. Cubos não são quadrados, distância não é velocidade. Engenharia de software não é programação.

----------------------------------------------------------------------------------------------------------------------------------

Comentário: 

A Engenharia de Software não significa somente programação. Envolve tarefas além do desenvolvimento como a modificação, 
manutenção e atualização de um software conforme as necessidades vão mudando ao longo do tempo.

Engenharia de software = Programação + Tempo + Escala + Trade-offs

- Programação + Tempo: como o código será mantido, modificado e adaptado ao longo do tempo.
- Escala: número de usuários que utilizam o software ao mesmo tempo.
- Trade-offs: analisar as vantagens e desvantagens de uso de uma determinada linguagem de programação ou software no 
desenvolvimento de um novo projeto.


Exemplos de trade-off:

1. Desempenho versus Manutenibilidade: muitas vezes, a otimização de desempenho de um sistema pode resultar em um código mais complexo e difícil de manter. Por exemplo, ao usar algoritmos altamente eficientes, pode ser necessário sacrificar a legibilidade do código. Esse trade-off é uma decisão entre o desempenho imediato do sistema e a facilidade de fazer alterações e correções no futuro.

2. Escalabilidade versus Custos: projetar um sistema para ser altamente escalável geralmente implica em investimentos significativos em infraestrutura e tecnologias mais avançadas. No entanto, esses investimentos podem aumentar os custos iniciais do projeto. Por outro lado, optar por uma abordagem mais simples pode reduzir os custos iniciais, mas pode resultar em problemas de escalabilidade conforme o sistema cresce. Portanto, há um trade-off entre a capacidade de escalabilidade do sistema e os custos associados à sua implementação.

3. Funcionalidade versus Prazos: muitas vezes, os desenvolvedores enfrentam o desafio de equilibrar a quantidade de funcionalidades desejadas em um sistema com os prazos de entrega do projeto. Adicionar mais funcionalidades pode tornar o produto mais atraente para os usuários, mas também pode aumentar a complexidade do desenvolvimento e estender os prazos. Por outro lado, priorizar prazos apertados pode resultar em um produto final com menos funcionalidades ou com possíveis falhas devido à pressa no desenvolvimento. Este é um trade-off entre a qualidade e a quantidade de funcionalidades entregues dentro do prazo estipulado.

----------------------------------------------------------------------------------------------------------------------------------
